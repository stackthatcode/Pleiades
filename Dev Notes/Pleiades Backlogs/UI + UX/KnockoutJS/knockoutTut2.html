<!DOCTYPE html>

<html>
<head>	
	<script type="text/javascript" src="jquery-1.8.2.min.js"></script>
	<script type="text/javascript" src="knockout-2.1.0.js"></script>	
	<script type="text/javascript">
		function Constructor2() {
			this.h = function() {
				alert("got it!");
			}
		}		
		
		function Constructor1() {
			this.x = 18;
			return function() { return 'abcdefgh'; };
		}
		
		var instance = new Constructor1();
		instance.method = function() { return '1234567' };
		
		console.log(instance() + " " + instance.x + " " + instance.method + " " + instance);		
		
		$(function() {
			// Class to represent a row in the seat reservations grid
			function SeatReservation(name, initialMeal) {
				// Constructor invocation means this isn't necessary, until the lambda function below
				var self = this;
				
				// Chose to make "name" observable... if it's not, changes to View Model won't be reflected in View
				// ALSO: ObservableArray only observes members of the array, not the member's members
				self.name = ko.observable(name);	
				self.meal = ko.observable(initialMeal);
				
				// Notice!  When passing a lambda function, we need a "self" pointer, since "this" points to global context/"window" (!!!)
				self.formattedPrice = ko.computed(function() {
					var price = self.meal().price;
					return price ? "$" + price.toFixed(2) : "None";
				});
			}
			
			// Overall viewmodel for this screen, along with initial state
			function ReservationsViewModel() {   
				var self = this;
				
				// Non-editable catalog data - would come from the server
				self.availableMeals = [
					{ mealName: "Standard (sandwich)", price: 150 },
					{ mealName: "Premium (lobster)", price: 34.95 },
					{ mealName: "Ultimate (whole zebra)", price: 290 }
				];
				
				// Editable data
				self.seats = ko.observableArray([
					new SeatReservation("Steve", self.availableMeals[0]),
					new SeatReservation("Bert", self.availableMeals[2]),
					new SeatReservation("Suzanna", self.availableMeals[1])
				]);				
				
				// Notice how the bound model object is what's passed to this method, hmmm....?
				self.removeSeat = function(seat) {
					self.seats.remove(seat);	// DON'T BE FOOLED!  
				}
				
				self.addSeat = function(input) {
					alert(input);
					alert(self.seats.unshift);
					alert(self.seats);
					
					self.seats.unshift(new SeatReservation("Ralph", self.availableMeals[1]));
				}
				
				// ko.computed makes this property respond to observable updates
				self.totalSurcharge = ko.computed(function() {
				   var total = 0;
				   for (var i = 0; i < self.seats().length; i++)
					   total += self.seats()[i].meal().price;
				   return total;
				});
			}
			
			ko.applyBindings(new ReservationsViewModel());
		});
	</script>
</head>

<body>
	
	<h2>Your seat reservations (<span data-bind="text: seats().length"></span>)</h2>
	<table>
		<thead><tr>
			<th>Passenger name</th><th></th><th>Meal</th><th>Surcharge</th><th></th>
		</tr></thead>
		<tbody data-bind="foreach: seats">
			<tr>
				<td><input data-bind="value: name" /></td>
				<td><span data-bind="text: name"></span></td>
				<td><select data-bind="options: $root.availableMeals, value: meal, optionsText: 'mealName'"></select></td>
				<td data-bind="text: meal().price"></td>
				<td><a href="#" data-bind="click: $root.removeSeat">Remove</a></td>				
			</tr>    
		</tbody>
	</table>
	
	<h3 data-bind="visible: totalSurcharge() > 0">
		Total surcharge: $<span data-bind="text: totalSurcharge().toFixed(2)"></span>
	</h3>
	<button data-bind="click: addSeat, enable: seats().length < 5">Reserve another seat</button>
</body>
</html>

